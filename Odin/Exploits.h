#pragma once
#include "includes.h"
#include "SDK/PL_Engine_classes.h"

// Recoil / Spread values
static FAccuracySettings OldAccuracy{};
static FRecoilSettings OldRecoil{};
static FAccuracySettings NewAccuracy{};
static FRecoilSettings NewRecoil{};


// Speedhack template class
template<class T>
class SpeedHackClass
{
private:
	int speed = 0;
	T initialoffset;
	T initialtime;
public:
	SpeedHackClass()
	{
		speed = 1.0;
	}
	SpeedHackClass(T _initialtime, T _initialoffset, int _speed = 1.0)
	{
		speed = _speed;
		initialoffset = _initialoffset;
		initialtime = _initialtime;
	}

	int get_speed() const { return speed; }

	T get(T currentTime)
	{
		T false_val = (T)((currentTime - initialtime) * speed) + initialoffset;
		return (T)false_val;
	}

	void set_speed(int _speed)
	{
		speed = _speed;
	}
};


SpeedHackClass<LONGLONG> h_QueryPerformanceCounter;
SpeedHackClass<DWORD> h_GetTickCount;
SpeedHackClass<ULONGLONG> h_GetTickCount64;
SpeedHackClass<DWORD> h_GetTime;

double lastspeed = 1.0; // Game speed lastspeed

BOOL WINAPI newQueryPerformanceCounter(LARGE_INTEGER* counter) {
	LARGE_INTEGER currentLi;
	LARGE_INTEGER falseLi;
	originalQueryPerformanceCounter(&currentLi);
	falseLi.QuadPart = h_QueryPerformanceCounter.get(currentLi.QuadPart);

	*counter = falseLi;
	return true;
}

DWORD WINAPI newGetTickCount() {
	auto res = h_GetTickCount.get(originalGetTickCount());

	return res;
}

ULONGLONG WINAPI newGetTickCount64() {
	auto res = h_GetTickCount64.get(originalGetTickCount64());

	return res;
}

DWORD WINAPI newTimeGetTime() {
	return h_GetTime.get(originalTimeGetTime());
}

LARGE_INTEGER initialtime64;
LARGE_INTEGER initialoffset64;

bool hooked, hook_once = false;
void doSpeedhack(bool state)
{
	// This is the QPC hook, it needs to be called only once.
	if (!hook_once)
	{
		// Set initial values for hooked calculations
		originalQueryPerformanceCounter(&initialtime64);
		initialoffset64 = initialtime64;

		h_QueryPerformanceCounter = SpeedHackClass<LONGLONG>(initialtime64.QuadPart, initialoffset64.QuadPart);
		h_GetTickCount = SpeedHackClass<DWORD>(originalGetTickCount(), originalGetTickCount());
		h_GetTickCount64 = SpeedHackClass<ULONGLONG>(originalGetTickCount64(), originalGetTickCount64());
		h_GetTime = SpeedHackClass<DWORD>(originalTimeGetTime(), originalTimeGetTime());

		DetourTransactionBegin();
		DetourUpdateThread(GetCurrentThread());
		DetourAttach(&(PVOID&)originalQueryPerformanceCounter, newQueryPerformanceCounter);
		DetourAttach(&(PVOID&)originalGetTickCount, newGetTickCount);
		DetourAttach(&(PVOID&)originalGetTickCount64, newGetTickCount64);
		DetourAttach(&(PVOID&)originalTimeGetTime, newTimeGetTime);
		DetourTransactionCommit();
		hook_once = true;
	}

	if (state && !hooked)
	{
		if (lastspeed != Settings.Speed)
		{
			originalQueryPerformanceCounter(&initialtime64);
			newQueryPerformanceCounter(&initialoffset64);

			h_QueryPerformanceCounter = SpeedHackClass<LONGLONG>(initialtime64.QuadPart, initialoffset64.QuadPart, Settings.Speed);
			h_GetTickCount = SpeedHackClass<DWORD>(originalGetTickCount(), newGetTickCount(), Settings.Speed);
			h_GetTickCount64 = SpeedHackClass<ULONGLONG>(originalGetTickCount64(), newGetTickCount64(), Settings.Speed);
			h_GetTime = SpeedHackClass<DWORD>(originalTimeGetTime(), newTimeGetTime(), Settings.Speed);

			lastspeed = Settings.Speed;
		}
		hooked = true;
	}
	// When we disable the speehack, we make the speed 1.
	else if (!state && hooked) {
		if (lastspeed != 1)
		{
			originalQueryPerformanceCounter(&initialtime64);
			newQueryPerformanceCounter(&initialoffset64);

			h_QueryPerformanceCounter = SpeedHackClass<LONGLONG>(initialtime64.QuadPart, initialoffset64.QuadPart, 1);
			h_GetTickCount = SpeedHackClass<DWORD>(originalGetTickCount(), newGetTickCount(), 1);
			h_GetTickCount64 = SpeedHackClass<ULONGLONG>(originalGetTickCount64(), newGetTickCount64(), 1);
			h_GetTime = SpeedHackClass<DWORD>(originalTimeGetTime(), newTimeGetTime(), 1);

			lastspeed = 1;
		}
		hooked = false;
	}
}

bool saved_recoil = false;
void setRecoil(bool state)
{
	if (!saved_recoil)
	{
		OldRecoil = Weapon->m_RecoilSettings;
		saved_recoil = true;
	}

	if (state)
	{
		NewRecoil.bUsesRecoil = 0;
		Weapon->m_RecoilSettings = NewRecoil;
	}
	else if (!state && saved_recoil)
	{
		Weapon->m_RecoilSettings = OldRecoil;
	}
}

bool saved_spread = false;
void setSpread(bool state)
{
	if (!saved_spread)
	{
		OldAccuracy = Weapon->m_AccuracySettings;
		saved_spread = true;
	}

	if (state)
	{
		NewAccuracy.bUsesAdvancedAccuracy = 1;
		NewAccuracy.fAccuracyGainPerSec = 0;
		NewAccuracy.fMaxAccuracy = 1;
		NewAccuracy.fMinAccuracy = 1;
		Weapon->m_AccuracySettings = NewAccuracy;
	}
	else if (!state && saved_recoil)
	{
		Weapon->m_AccuracySettings = OldAccuracy;
	}
}


void Exploits() {
	if (Settings.Speedhack)
		doSpeedhack(true);
	else
		doSpeedhack(false);

	// Only do noSpread / noRecoil if Player & Weapon both are valid pointers.
	if (!IsValid((DWORD64)AcknowledgedPawn)) return;
	if (!IsValid((DWORD64)Weapon)) return;

	if (Settings.ESP.Glow)
		AcknowledgedPawn->r_bIsWallHacking |= (1u << 17);
	else
		AcknowledgedPawn->r_bIsWallHacking &= ~(1u << 17);

	if (Settings.NoSpread)
		setSpread(true);
	else
		setSpread(false);

	if (Settings.NoRecoil)
		setRecoil(true);
	else
		setRecoil(false);

	if (Settings.ThirdPerson)
		Weapon->m_fForce3PPersistTimer = 5;
	else
		Weapon->m_fForce3PPersistTimer = 0;
}
